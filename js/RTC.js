/*!
 * RTC.js - Low level abstraction for Real Time Communication 
 * ---
 * @author Joram Ruitenschild
 * @version 0.0.1-beta
 * @updated 21-JUNE-2013
 * ---
 * @license Dual licensed under the MIT and GPL licenses
 * @info https://github.com/JrSchild/RTC.js
 */
(function( window, undefined ) {
	"use strict";
	
	var RTC;
	
	navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
	
	window.RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection;
	
	if( navigator.mozGetUserMedia ) {
		window.RTCSessionDescription = window.mozRTCSessionDescription;
		window.RTCIceCandidate       = window.mozRTCIceCandidate;
		window.RTCPeerConnection     = window.mozRTCPeerConnection;
	}
	
	/**
	 * The constructor function doesn't do anything but set the attributes.
	 * @return {self}
	 */
	RTC = function( data ) {
		this.data = data || {};
		this.options = data.options || {};
	};
	
	/**
	 * The call function, this handles all the signaling logic internally.
	 * It includes all helper functions
	 * @return {void}
	 */
	RTC.prototype.call = function( options ) {
		this.options = options || this.options;
		
	var
		_this = this,
		mediaConstraints = {
			"mandatory": {
				"OfferToReceiveAudio": this.options.video || true, 
				"OfferToReceiveVideo": this.options.audio || true
			}
		},
		peerConnection = createPeerConnection();
		
		// Add local stream to the peer connection.
		console.log( "Adding local stream." );
		peerConnection.addStream( RTC.localStream );
		
		RTC.socket.on( "Signaling", function( data ) {
			processSignalingMessage( data );
		});
		
		if( this.data.client ) {
			RTC.once( "Connect", this.data, function( data ) {
				if( data.connectionID ) {
					data.type = "call";
					
					// Set the options to the local data object, so the other client has this info too.
					data.options = _this.options;
					
					// set connection ID generated by the server
					_this.connectionID = data.connectionID;
					
					// Both clients are in one room. Now call it.
					// Because an offer expires after a few seconds we can't send the offer and wait for
					// the user to manually respond to it. So we'll let the other client send the offer back.
					RTC.socket.emit( "Signaling", data );
				}
			});
		} else {
			this.connectionID = this.data.connectionID;
			
			// Answer offer
			processSignalingMessage( this.data );
		}
		
		/** =======================
		 *  PRIVATE CLASS FUNCTIONS
		 ** ======================= */
		
		/**
		 * Set parameter for creating a peer connection and add a callback function for messaging by peer connection
		 * @return {void}
		 */
		function createPeerConnection() {
			var pc_config = { "iceServers": [{ "url": "stun:" + RTC.STUN }] },
				pcConstraints = { "optional": [{ "DtlsSrtpKeyAgreement": true }] },
				peerConnection;
			
			try {
				peerConnection = new window.RTCPeerConnection( pc_config, pcConstraints );
				peerConnection.onicecandidate = onIceCandidate;
				console.log( "Created webkitRTCPeerConnnection with config:", pc_config );
			} catch( e ) {
				console.log( "Failed to create PeerConnection, exception: " + e.message );
				return;
			}
			
			peerConnection.onconnecting   = onSessionConnecting;
			peerConnection.onopen         = onSessionOpened;
			peerConnection.onaddstream    = onRemoteStreamAdded;
			peerConnection.onremovestream = onRemoteStreamRemoved;
			
			return peerConnection;
		}
		
		/**
		 * Process signaling messages
		 * @param  {object} message : incoming object
		 * @return {void}
		 */
		function processSignalingMessage( message ) {
			if( _this.connectionID !== message.connectionID ) {
				return;
			}
			
			if( message.type === "call" ) {
				peerConnection.createOffer( setLocalAndSendMessage , null, mediaConstraints );
			} else if( message.type === "offer" ) {
				peerConnection.setRemoteDescription( new window.RTCSessionDescription( message ) );
				
				// Answer back
				console.log( "Sending answer to peer." );
				peerConnection.createAnswer( setLocalAndSendMessage, null, mediaConstraints );
			} else if( message.type === "answer" ) {
				peerConnection.setRemoteDescription( new window.RTCSessionDescription( message ) );
			} else if( message.type === "candidate" ) {
				var candidate = new window.RTCIceCandidate({
					sdpMLineIndex: message.label,
					candidate: message.candidate
				});
				peerConnection.addIceCandidate( candidate );
			} else if( message.type === "bye" ) {
				_this.fire( "onRemoteHangup", message );
			}
		}
		
		/**
		 * @return {void}
		 */
		function setLocalAndSendMessage( sessionDescription ) {
			peerConnection.setLocalDescription( sessionDescription );
			
			var data = {
				connectionID: _this.connectionID,
				type: sessionDescription.type,
				sdp: sessionDescription.sdp
			};
			
			console.log( "C->S: ", data );
			
			// send offer
			RTC.socket.emit( "Signaling", data );
		}
		
		/**
		 * Function called by the peerConnection method for the signaling process between clients
		 * @param  {message} message : generated by the peerConnection API to send SDP message
		 * @return {void}
		 */
		function onIceCandidate( event ) {
			if( event.candidate ) {
				console.log( "Sending RTCCandidate" );
				
				var data = {
					type: "candidate",
					connectionID: _this.connectionID,
					label: event.candidate.sdpMLineIndex,
					id: event.candidate.sdpMid,
					candidate: event.candidate.candidate
				};
				
				RTC.socket.emit( "Signaling", data );
			} else {
				console.log( "End of candidates. Event: ", event );
			}
		}
		
		/**
		 * Get the remote stream and add it to the page with a url
		 * @param  {event} event : event given by the browser
		 * @return {void}
		 */
		function onRemoteStreamAdded( event ) {
			console.log( "Remote stream added.", event );
			
			_this.remoteStream    = event.stream;
			_this.remoteStreamUrl = window.URL.createObjectURL( event.stream );
			
			_this.fire( "onReady", {
				streamUrl: _this.remoteStreamUrl,
				stream:    _this.remoteStream
			});
		}
		
		/**
		 * Called when the peer connection is connecting
		 * @param  {message} message
		 * @return {void}
		 */
		function onSessionConnecting( message ) {      
			console.log( "Session connecting.", message );
		}
		
		/**
		 * Called when the session between clients is established
		 * @param  {message} message
		 * @return {void}
		 */
		function onSessionOpened( message ) {      
			console.log( "Session opened.", message );
		}
		
		/**
		 * Called when the remote stream has been removed
		 * @param  {event} event : event given by the browser
		 * @return {void}
		 */
		function onRemoteStreamRemoved( event ) {
			console.log( "Remote stream removed.", event );
		}
		return this;
	};
	
	/**
	 * onRemoteHangup fires when the connection is stopped
	 */
	RTC.prototype.onRemoteHangup = function( callback ) {
		return this.bind( "onRemoteHangup", callback );
	};
	
	/**
	 * onReady fires when the connection is established
	 */
	RTC.prototype.onReady = function( callback ) {
		return this.bind( "onReady", callback );
	};
	
	/**
	 * The unique connectionID used to identify connection
	 * between two peers
	 */
	RTC.prototype.connectionID = undefined;
	
	/**
	 * Incoming stream from other client.
	 */
	RTC.prototype.remoteStream = undefined;
	
	/**
	 * Toggle the sound of the remote stream or turn it off or on
	 * by passing true or false.
	 */
	RTC.prototype.toggleSound = function( force ) {
		var audioTrack = this.remoteStream.getAudioTracks()[0];
		
		if( audioTrack ) {
			audioTrack.enabled = ( force !== undefined ) ? force :
								( ( audioTrack.enabled === true ) ? false : true );
		}
		
		return this;
	};
	
	/** =====================================================
	 *  PUBLIC METHODS AND VARIABLES ON THE GLOBAL RTC OBJECT
	 ** ===================================================== */
	
	/**
	 * Set the used STUN server
	 */
	RTC.STUN = "stun.l.google.com:19302";
	
	/**
	 * The socket.io connection that will be used for messaging
	 */
	RTC.socket = undefined;
	
	/**
	 * Once the local stream is established it will be
	 * stored in here, as well as in connection1.localStream
	 */
	RTC.localStream = undefined;
	
	/**
	 * Once the local stream is established it's URL will be
	 * accesible through this variable.
	 */
	RTC.localStreamUrl = undefined;
	
	/**
	 * room of the client, will be set after connection has been made
	 * and the server says it's okay to join the room.
	 */
	RTC.roomID = undefined;
	
	/**
	 * Event system, allows attaching event listeners for callbacks.
	 * http://www.nczonline.net/blog/2010/03/09/custom-events-in-javascript/
	 */
	RTC._listeners = RTC.prototype._listeners = {};
	
	RTC.bind = RTC.prototype.bind = function( type, listener ) {
		if( typeof this._listeners[type] === "undefined" ) {
			this._listeners[type] = [];
		}
		
		this._listeners[type].push( listener );
		
		return this;
	};
	
	RTC.fire = RTC.prototype.fire = function( event, data ) {
		if( typeof event === "string" ) {
			event = { type: event };
		}
		
		if( this._listeners[ event.type ] instanceof Array ) {
			var listeners = this._listeners[ event.type ];
			
			for( var i = 0, len = listeners.length; i < len; i++ ) {
				// if data is not defined pass event first, else pass event as 2nd.
				listeners[i].call( this, data || event, data && event );
			}
		}
		
		return this;
	};
	
	/**
	 * Called when the remote stream has been added
	 * @param  {event} event : event given by the browser
	 * @return {void}
	 */
	RTC.onLocalStreamAdded = function( callback ) {
		return this.bind( "onLocalStreamAdded", callback );
	};
	
	RTC.onIncoming = function( callback ) {
		return this.bind( "onIncoming", callback );
	};
	
	/**
	 * Join the room on the server, after server says it's okay
	 * set global roomID
	 */
	RTC.join = function( roomID, callback ) {
		doGetUserMedia(function() {
			// listen for incoming offers and send the offers to the onIncoming callback
			RTC.socket.on( "Signaling", function( data ) {
				if( data.type === "call" ) {
					RTC.fire( "onIncoming", data );
				}
			});
			RTC.once( "JoinRoom", { roomID: roomID }, function( data ) {
				if( data.status === "OK" ) {
					RTC.roomID = roomID;
					callback();
				}
			});		
		});
		
		return this;
	};
	
	/**
	 * Get a list of users from the server, this has been constructed in such a way
	 * that it won't collide when called multiple times.
	 */
	RTC.getUserList = function( callback ) {
		return RTC.once( "getUserList", callback );
	};
	
	/**
	 * Method to call a listener on the server with a callback,
	 * makes sure the event is only executed once by assigning a unique id
	 */
	RTC.once = function( action, data, callback ) {
		if( typeof data === "function" ) {
			callback = data;
			data = {};
		}
		
		// uuid is used to identify a unique listener and remove this after it's called
		var uuid = data.uuid = +( "" + Math.random() ).replace( ".", "" );
		
		RTC.socket.emit( action, data );
		RTC.socket.on( action + uuid, function( data ) {
			RTC.socket.removeAllListeners( action + uuid );
			delete data.uuid;
			callback( data );
		});
		
		return this;
	};
	
	/** ========================
	 *  PRIVATE HELPER FUNCTIONS
	 ** ======================== */
	
	/**
	 * get the media (audio or video) of the user
	 * @return {void}
	 */
	function doGetUserMedia( callback ) {
		try {
			navigator.getUserMedia({
				"audio": true,
				"video": {
					"mandatory": {},
					"optional": []
				}
			}, onUserMediaSuccess( callback ), onUserMediaError );
			console.log( "Requested access to local media." );
		} catch( e ) { }
	}
	
	/**
	 * Callback function for getUserMedia() on success getting the media
	 * create an url for the current stream
	 * @param  {stream} stream : contains the video and/or audio streams
	 * @return {void}
	 */
	function onUserMediaSuccess( callback ) {
		return function( stream ) {
			console.log( "User has granted access to local media." );
			
			RTC.localStream    = stream;
			RTC.localStreamUrl = window.URL.createObjectURL( stream );
			
			RTC.fire( "onLocalStreamAdded", {
				streamUrl: RTC.localStreamUrl,
				stream:    RTC.localStream
			});
			callback();
		};
	}
	
	/**
	 * Callback function for getUserMedia() on fail getting the media
	 * @param  {error} error : informations about the error
	 * @return {void}
	 */
	function onUserMediaError( error ) {
		console.log( "Failed to get access to local media. Error code was: " + error.code );
		alert( "Failed to get access to local media. Error code was: " + error.code );    
	}
	
	window.RTC = RTC;
	
})( window );